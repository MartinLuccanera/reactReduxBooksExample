/* A reducer is a function that returns a piece of app's state. Because our app can have many pieces of state, we can
have many reducers.
This process has 2 steps:
1) Writing the reducer.
2) Wiring it into the app.
 */

export default function() {
    return [
        {title: 'JavaScript: The Good Parts', pages: 101 },
        {title: 'Harry Potter', pages: 39 },
        {title: 'The Dark Tower', pages: 85 },
        {title: 'Eloquent Ruby', pages: 1 }
    ]
}

/* App's flow: (also read README.md for an overview of the flow)
 * Our Application's state is generated by reducer functions. We have (so far) 1 reducer called reducer_books.
 * It always returns an array of books. The array contains a list of objects where each represents a book and (so far)
 * only has the book title.
 * We added the books reducer to the combinedReducers in reducers/index.js which will add a key to our global application
 * state called books. Where the 'Key' is books, and the value is whatever gets returned from BooksReducer (our array of books).
 * Our state is always gonna be equal to an object with a key of books and a value of an array of books.
 *
 * We also created a component called book_list. It started off as a component but then we decided that it needed to be
 * aware of our state within the redux side of our app. Hence, we promoted it to be a container (via importing connect
 * From redux and then defining mapStateToProps and mapping that to BookList via the 'connect' function). We decided to
 * only map BookList as the parent of it (index) doesn't care about the list of books.
 *
 * Then, we made sure that app renders the BookList. When all this renders in the browser -> Redux generated a state object
 * that contained our books and then mapped that state as 'props' to our component. As the state was updated (through our reducer)
 * our component re-rendered with our list of books. 
 */